#include <functional>
#include <numeric>

// Google test includes
#include "gtest/gtest.h"

// Autogenerated simulation code includess
#include "post_vars_in_synapse_dynamics_sparse_CODE/definitions.h"

// **NOTE** base-class for simulation tests must be
// included after auto-generated globals are includes
#include "../../utils/simulation_test.h"

//----------------------------------------------------------------------------
// PostVarsInSynapseDynamicsSparseTest
//----------------------------------------------------------------------------
class PostVarsInSynapseDynamicsSparseTest : public SimulationTest
{
protected:
  //--------------------------------------------------------------------------
  // SimulationTest virtuals
  //--------------------------------------------------------------------------
  virtual void Init()
  {
    // Initialise neuron parameters
    for (int i = 0; i < 10; i++)
    {
      shiftpre[i] = i * 10.0f;
      shiftpost[i] = i * 10.0f;
    }

    #define SETUP_THE_C(I)  \
      case I:               \
        allocatesyn##I(10); \
        theC= &Csyn##I;     \
        break;

    // all different delay groups get same connectivity
    for(int i = 0; i < 10; i++)
    {
        // **YUCK** extract correct sparse projection
        SparseProjection *theC;
        switch (i)
        {
          SETUP_THE_C(0)
          SETUP_THE_C(1)
          SETUP_THE_C(2)
          SETUP_THE_C(3)
          SETUP_THE_C(4)
          SETUP_THE_C(5)
          SETUP_THE_C(6)
          SETUP_THE_C(7)
          SETUP_THE_C(8)
          SETUP_THE_C(9)
        };

        // loop through pre-synaptic neurons
        for(int j = 0; j < 10; j++)
        {
            // each pre-synatic neuron gets one target neuron
            unsigned int trg= (j + 1) % 10;
            theC->indInG[j]= j;
            theC->ind[j]= trg;
        }
        theC->indInG[10]= 10;
    }

    m_TheW[0] = wsyn0;
    m_TheW[1] = wsyn1;
    m_TheW[2] = wsyn2;
    m_TheW[3] = wsyn3;
    m_TheW[4] = wsyn4;
    m_TheW[5] = wsyn5;
    m_TheW[6] = wsyn6;
    m_TheW[7] = wsyn7;
    m_TheW[8] = wsyn8;
    m_TheW[9] = wsyn9;

    // for all synapse groups
    for(int i = 0; i < 10; i++)
    {
        // for all synapses
        for(int j = 0; j < 10; j++)
        {
            m_TheW[i][j]= 0.0f;
        }
    }

    // Initialize sparse projection
    initpost_vars_in_synapse_dynamics_sparse();
  }

  //--------------------------------------------------------------------------
  // Protected methods
  //--------------------------------------------------------------------------
  float *GetTheW(unsigned int delay) const
  {
    return m_TheW[delay];
  }


private:
  //--------------------------------------------------------------------------
  // Members
  //--------------------------------------------------------------------------
  float *m_TheW[10];
};

TEST_P(PostVarsInSynapseDynamicsSparseTest, AcceptableError)
{
  float err = 0.0f;
  float x[10][10];
  for (int i = 0; i < (int)(20.0f / DT); i++)
  {
    t = i * DT;

    // for each delay
    for (int d = 0; d < 10; d++)
    {
        // for all pre-synaptic neurons
        for (int j = 0; j < 10; j++)
        {
            if (t > 0.0001+DT)
            {
                x[d][j] = t-2*DT+10*((j+1)%10);
            }
            else if(i == 0)
            {
                x[d][j] = 0.0f;
            }
        }

        // Add error for this time step to total
        err += std::inner_product(&x[d][0], &x[d][10],
                                  GetTheW(d),
                                  0.0,
                                  std::plus<float>(),
                                  [](float a, float b){ return abs(a - b); });
    }

    // Step simulation
    Step();
  }

  // Check total error is less than some tolerance
  EXPECT_LT(err, 5e-3);
}

#ifndef CPU_ONLY
auto simulatorBackends = ::testing::Values(true, false);
#else
auto simulatorBackends = ::testing::Values(false);
#endif

INSTANTIATE_TEST_CASE_P(Backends,
                        PostVarsInSynapseDynamicsSparseTest,
                        simulatorBackends);