/*--------------------------------------------------------------------------
   Author: Thomas Nowotny
  
   Institute: Center for Computational Neuroscience and Robotics
              University of Sussex
	      Falmer, Brighton BN1 9QJ, UK 
  
   email to:  T.Nowotny@sussex.ac.uk
  
   initial version: 2010-02-07
  
--------------------------------------------------------------------------*/

//----------------------------------------------------------------------------
/*! \page Quickstart_sec Quickstart 

GeNN is based on the idea of code generation for the involved GPU or
CPU simulation code for neuronal network models but leaves a lot of
freedom how to use the generated code in the final
application. To facilitate the use of GeNN on the background of this
philosophy it comes with a number of complete examples containing both
the model description code that is used by GeNN for code generation
and the "user side code" to run the generated model and safe the
results. Running these complete examples should be achievable in a few
minutes. The necessary steps are described below.

\subsection unix_quick Unix Quickstart
In order to get a quick start and run a provided model, open a
shell, navigate to `GeNN/tools` and type 
\code
make
\endcode 
This will compile additional tools for creating and running example projects.
For a first complete test, the system is best used with a full driver
program such as in the \ref ex_mbody example:
\code{.cc} 
tools/generate_run [CPU/GPU] [#AL] [#KC] [#LH] [#DN] [gscale] [DIR] [EXE] [MODEL] [DEBUG OFF/ON]. 
\endcode
To compile `generate_run.cc`, navigate to the `userproject/MBody1_project` directory and type
\code
make all
\endcode
This will generate an executable that you can invoke with, e.g.,
\code{.cc} 
./generate_run 1 100 1000 20 100 0.0025 test1 MBody1 0 
\endcode
which would generate and simulate a model of the locust olfactory
system with 100 projection neurons, 1000 Kenyon cells, 20 lateral horn
interneurons and 100 output neurons n the mushroom body lobes.  

The tool generate_run will generate connectivity matrices for the model
`MBody1` and store them into files, compile and run the model on the GPU
using these files as inputs and output the resulting spiking
activity. To fix the GPU used, replace the first argument `1` with the
device number of the desired GPU plus 2, e.g., `2` for GPU 0. All input and output files will be prefixed with `test1` and will be
created in a sub-directory with the name `test1_output`. The last
parameter `0` will switch the debugging mode off, `1` would switch it
on. More about debugging in the \link Debugging_sec debugging section \endlink.

The MBody1 example is already a highly integrated example that
showcases many of the features of GeNN and how to program the
user-side code for a GeNN application. More details in the \link UserManual_sec User Manual \endlink

\subsection windows_quick Windows Quickstart

All interaction with GeNN programs are command-line based and hence
are executed within a `cmd` window. Open a `cmd` window and navigate
to the `userprojects\tools` directory.
\code
cd %GENN_PATH%\userprojects\tools
\endcode
Then type
\code
make.bat all
\endcode
to compile a numberof tools that are used by the example projects to
generate connectivity and inputs to model networks.

The navigate to the `MBody1_project` directory.
\code
cd ..\MBody1_project
\endcode
By typing
\code
make.bat all
\endcode
you can compile the `generate_run` engine that allows to run a \ref
ex_mbody model of the insect mushroom body:
\code{.cc} 
tools/generate_run [CPU/GPU] [#AL] [#KC] [#LH] [#DN] [gscale] [DIR] [EXE] [MODEL] [DEBUG OFF/ON]. 
\endcode
To invoke `generate_run.exe` type, e.g.,
\code{.cc} 
generate_run.exe 1 100 1000 20 100 0.0025 test1 MBody1 0 
\endcode
which would generate and simulate a model of the locust olfactory
system with 100 projection neurons, 1000 Kenyon cells, 20 lateral horn
interneurons and 100 output neurons n the mushroom body lobes.  

The tool `generate_run.exe` will generate connectivity matrices for the model
`MBody1` and store them into files, compile and run the model on an
automatically chosen GPU
using these files as inputs and output the resulting spiking
activity. To fix the GPU used, replace the first argument `1` with the
device number of the desired GPU plus 2, e.g., `2` for GPU 0. All input and output files will be prefixed with `test1` and will be
created in a sub-directory with the name `test1_output`. The last
parameter `0` will switch the debugging mode off, `1` would switch it
on. More about debugging in the \link Debug debugging section \endlink.

The MBody1 example is already a highly integrated example that
showcases many of the features of GeNN and how to program the
user-side code for a GeNN application. \link Manual More details in the User Manual \endlink

\section how_to How to use GeNN

The most common way to use GeNN is to create or modify a program such as `userproject/MBody1_project/generate_run.cc`.

In more detail, what `generate_run` and similar programs do is: 
1. use other tools to generate connectivity
matrices and store them into files.

2. build the source code of a model simulation. In the example of the
MBody1_project this entails writing neuron numbers into
`userproject/include/sizes.h`, and executing `buildmodel.sh MBody1 [DEBUG
OFF/ON]`. The `buildmodel.sh` script compiles the installed code
generator in conjunction with the model description, in this example
`model/MBody1.cc`, and executes the code generator to generate the
complete model simulation code for the MBody1 model.

3. compile the generated model code, that can be found in
`model/MBody1_CODE/` by invoking `make clean && make` in the `model`
directory. It is at this stage that GeNN generated model simulation
code is combined with user-side run-time code, in this example
`classol_sim.cu` (classify-olfaction-simulation) which uses the
`map_classol` class.
 
4. finally run the resulting stand-alone
simulator executable, in the MBody1 example `classol_sim` in the `model` directory.

The `generate_run` tool is only a suggested usage scenario of
GeNN. Alternatively, users can manually execute the four steps 
above or integrate GeNN with development environments of their own
choice. 

\note
The usage scenario described was made explicit for Unix
environments. In Windows the setup is essentially the same except for
the usual operating system dependent syntax differences, e.g. the
build script is named buildmodel.bat, compilation of the generated
model simulator would be `make.bat clean && make.bat all`, or, `nmake
/f WINmakefile clean && nmake /f WINmakefile all`, and the resulting
executable would be named `classol_sim.exe`.

\section exs Example projects
GeNN comes with several example projects which show how to use its features. 
The MBody1 example discussed above is one of the many provided examples
that are described in more detail in \link Examples Example projects\endlink.

\section ownmodel Defining your own model
If one was to use the library for GPU code generation only, the following would be done:

a) The model in question is defined in a file, say "Model1.cc".  

b) this file needs to 
	<ol type='i'>
  <li> define "DT" 
  <li> include "modelSpec.h" and "modelSpec.cc"
  <li> define the values for initial variables and parameters for neuron and synapse populations
  <li> contain the model's definition in the form of a function 
\code{.cc}
  void modelDefinition(NNmodel &model); 
\endcode  
	"MBody1.cc" shows a typical example.
	</ol>
c) The programmer defines his/her own modeling code along similar lines as
"map_classol.*" together with "classol_sim.*". In this code, 

- she defines the connectivity matrices between neuron groups. (In the
example here those are read from files).  

- she defines input patterns (e.g. for Poisson neurons like in the
example) 

- she uses "stepTimeGPU(x, y, z);" to run one time step on the GPU or
"stepTimeCPU(x, y, z);" to run one on the CPU. (both versions are
always compiled). However, mixing the two does not make too much
sense. The host version uses the same memory whereto results from the
GPU version are copied (see next point) 

- she uses functions like "copyStateFromDevice();" etc to obtain
results from GPU calculations.

*/
//----------------------------------------------------------------------------
