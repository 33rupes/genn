Ge\+N\+N is based on the idea of code generation for the involved G\+P\+U or C\+P\+U simulation code for neuronal network models but leaves a lot of freedom how to use the generated code in the final application. To facilitate the use of Ge\+N\+N on the background of this philosophy it comes with a number of complete examples containing both the model description code that is used by Ge\+N\+N for code generation and the \char`\"{}user side code\char`\"{} to run the generated model and safe the results. Running these complete examples should be achievable in a few minutes. The necessary steps are described below.\hypertarget{Quickstart_unix_quick}{}\section{Running an Example Model in Unix}\label{Quickstart_unix_quick}
In order to get a quick start and run a provided model, open a shell, navigate to {\ttfamily Ge\+N\+N/tools} and type 
\begin{DoxyCode}
make
\end{DoxyCode}
 This will compile additional tools for creating and running example projects. For a first complete test, the system is best used with a full driver program such as in the \hyperlink{Examples_ex_mbody}{Insect Olfaction Model} example\+: 
\begin{DoxyCode}
tools/generate\_run [\hyperlink{modelSpec_8h_ad703205f9a4d4bb6af9c25257c23ce6d}{CPU}/\hyperlink{modelSpec_8h_a39cb9803524b6f3b783344b2f89867b4}{GPU}] [#AL] [#KC] [#LH] [#DN] [gscale] [OUTNAME] [MODEL] [DEBUG] [FTYPE] [
      REUSE]. 
\end{DoxyCode}


To compile {\ttfamily generate\+\_\+run.\+cc}, navigate to the {\ttfamily userproject/\+M\+Body1\+\_\+project} directory and type 
\begin{DoxyCode}
make all
\end{DoxyCode}
 This will generate an executable that you can invoke with, e.\+g., 
\begin{DoxyCode}
./generate\_run 1 100 1000 20 100 0.0025 test1 MBody1 0 \hyperlink{modelSpec_8h_ae8690abbffa85934d64d545920e2b108}{FLOAT} 0
\end{DoxyCode}
 which would generate and simulate a model of the locust olfactory system with 100 projection neurons, 1000 Kenyon cells, 20 lateral horn interneurons and 100 output neurons n the mushroom body lobes.

The tool generate\+\_\+run will generate connectivity matrices for the model {\ttfamily M\+Body1} and store them into files, compile and run the model on the G\+P\+U using these files as inputs and output the resulting spiking activity. To fix the G\+P\+U used, replace the first argument {\ttfamily 1} with the device number of the desired G\+P\+U plus 2, e.\+g., {\ttfamily 2} for G\+P\+U 0. All input and output files will be prefixed with {\ttfamily test1} and will be created in a sub-\/directory with the name {\ttfamily test1\+\_\+output}. The third to last parameter {\ttfamily 0} will switch the debugging mode off, {\ttfamily 1} would switch it on. More about debugging in the \hyperlink{}{debugging section }. The parameter {\ttfamily F\+L\+O\+A\+T} will run the model in float (single precision floating point), using {\ttfamily D\+O\+U\+B\+L\+E} would use double precision. The last parameter regulates whether previously generated files for connectivity and input should be reused (1) or files should be generated anew (0).

The M\+Body1 example is already a highly integrated example that showcases many of the features of Ge\+N\+N and how to program the user-\/side code for a Ge\+N\+N application. More details in the \hyperlink{UserManual}{User Manual }\hypertarget{Quickstart_windows_quick}{}\section{Running an Example Model in Windows}\label{Quickstart_windows_quick}
All interaction with Ge\+N\+N programs are command-\/line based and hence are executed within a {\ttfamily cmd} window. Open a {\ttfamily cmd} window and navigate to the {\ttfamily userprojects\textbackslash{}tools} directory. 
\begin{DoxyCode}
cd %GENN\_PATH%\(\backslash\)userprojects\(\backslash\)tools
\end{DoxyCode}
 Then type 
\begin{DoxyCode}
make.bat all
\end{DoxyCode}
 to compile a number of tools that are used by the example projects to generate connectivity and inputs to model networks.

The navigate to the {\ttfamily M\+Body1\+\_\+project} directory. 
\begin{DoxyCode}
cd ..\(\backslash\)MBody1\_project
\end{DoxyCode}
 By typing 
\begin{DoxyCode}
make.bat all
\end{DoxyCode}
 you can compile the {\ttfamily generate\+\_\+run} engine that allows to run a \hyperlink{Examples_ex_mbody}{Insect Olfaction Model} model of the insect mushroom body\+: 
\begin{DoxyCode}
tools/generate\_run [\hyperlink{modelSpec_8h_ad703205f9a4d4bb6af9c25257c23ce6d}{CPU}/\hyperlink{modelSpec_8h_a39cb9803524b6f3b783344b2f89867b4}{GPU}] [#AL] [#KC] [#LH] [#DN] [gscale] [DIR] [EXE] [MODEL] [DEBUG OFF/ON]. 
\end{DoxyCode}
 To invoke {\ttfamily generate\+\_\+run.\+exe} type, e.\+g., 
\begin{DoxyCode}
generate\_run.exe 1 100 1000 20 100 0.0025 test1 MBody1 0 
\end{DoxyCode}
 which would generate and simulate a model of the locust olfactory system with 100 projection neurons, 1000 Kenyon cells, 20 lateral horn interneurons and 100 output neurons n the mushroom body lobes.

The tool {\ttfamily generate\+\_\+run.\+exe} will generate connectivity matrices for the model {\ttfamily M\+Body1} and store them into files, compile and run the model on an automatically chosen G\+P\+U using these files as inputs and output the resulting spiking activity. To fix the G\+P\+U used, replace the first argument {\ttfamily 1} with the device number of the desired G\+P\+U plus 2, e.\+g., {\ttfamily 2} for G\+P\+U 0. All input and output files will be prefixed with {\ttfamily test1} and will be created in a sub-\/directory with the name {\ttfamily test1\+\_\+output}. The last parameter {\ttfamily 0} will switch the debugging mode off, {\ttfamily 1} would switch it on. More about debugging in the \hyperlink{}{debugging section }.

The M\+Body1 example is already a highly integrated example that showcases many of the features of Ge\+N\+N and how to program the user-\/side code for a Ge\+N\+N application. \hyperlink{}{More details in the User Manual }\hypertarget{Quickstart_how_to}{}\section{How to use Ge\+N\+N for New Projects}\label{Quickstart_how_to}
Creating and running projects in Ge\+N\+N involves a few steps ranging from defining the fundamentals of the model, inputs to the model, dteails of the model like specific connectivity matrices or initial values, running the model and analyzing or saving the data.

The most common way to use Ge\+N\+N is to create or modify a program such as {\ttfamily \hyperlink{userproject_2MBody1__project_2generate__run_8cc}{userproject/\+M\+Body1\+\_\+project/generate\+\_\+run.\+cc}} that wraps around other programs that are used for each of the necessary steps listed above. In more detail, what {\ttfamily generate\+\_\+run} and similar programs do is\+:


\begin{DoxyEnumerate}
\item To use other tools (programs) to generate connectivity matrices and store them into files.
\item To build the source code of a model simulation using Ge\+N\+N. In the example of the M\+Body1\+\_\+project this entails writing neuron numbers into {\ttfamily \hyperlink{sizes_8h}{userproject/include/sizes.\+h}}, and executing 
\begin{DoxyCode}
buildmodel.sh MBody1 [DEBUG OFF/ON]
\end{DoxyCode}
 The {\ttfamily buildmodel.\+sh} script compiles the installed Ge\+N\+N code generator in conjunction with the user-\/provided model description (see \hyperlink{Quickstart_ownmodel}{below}), in this example {\ttfamily model/\+M\+Body1.\+cc}. It then executes the Ge\+N\+N code generator to generate the complete model simulation code for the M\+Body1 model.
\item To compile the generated model code, that can be found in {\ttfamily model/\+M\+Body1\+\_\+\+C\+O\+D\+E/} by invoking {\ttfamily make clean \&\& make} in the {\ttfamily model} directory. It is at this stage that Ge\+N\+N generated model simulation code is combined with user-\/side run-\/time code, in this example {\ttfamily classol\+\_\+sim.\+cu} (classify-\/olfaction-\/simulation) which uses the {\ttfamily map\+\_\+classol} (map-\/neuron-\/based-\/classifier-\/olfaction) class.
\item To finally run the resulting stand-\/alone simulator executable, in the M\+Body1 example {\ttfamily classol\+\_\+sim} in the {\ttfamily model} directory.
\end{DoxyEnumerate}

The {\ttfamily generate\+\_\+run} tool is only a suggested usage scenario of Ge\+N\+N. Alternatively, users can manually execute the four steps above or integrate Ge\+N\+N with development environments of their own choice.

\begin{DoxyNote}{Note}
The usage scenario described was made explicit for Unix environments. In Windows the setup is essentially the same except for the usual operating system dependent syntax differences, e.\+g. the build script is named buildmodel.\+bat, compilation of the generated model simulator would be {\ttfamily make.\+bat clean \&\& make.\+bat all}, or, {\ttfamily nmake /f W\+I\+Nmakefile clean \&\& nmake /f W\+I\+Nmakefile all}, and the resulting executable would be named {\ttfamily classol\+\_\+sim.\+exe}.
\end{DoxyNote}
Ge\+N\+N comes with several example projects which showcase how to use its features. The M\+Body1 example discussed above is one of the many provided examples that are described in more detail in \hyperlink{Examples}{Example projects}.\hypertarget{Quickstart_ownmodel}{}\section{Defining a New Model in Ge\+N\+N}\label{Quickstart_ownmodel}
According to the workflow outlined above, there are several steps to be completed to define a neuronal network model.


\begin{DoxyEnumerate}
\item The neuronal network of interest is defined in a model definitoin file, e.\+g. {\ttfamily Example1.\+cc}. \begin{DoxyNote}{Note}
Ge\+N\+N follows a convention in which C/\+C++ files end with {\ttfamily .cc} and the model definition file will only be recognizd by the {\ttfamily buildmodel.\+sh} or {\ttfamily buildmodel.\+bat} scripts if it follows this convention and ends on {\ttfamily .cc}.
\end{DoxyNote}

\item Within the the model definition file {\ttfamily Example1.\+cc}, the following tasks need to be completed\+:

a) The time step {\ttfamily D\+T} needs to be defined, e.\+g. 
\begin{DoxyCode}
\textcolor{preprocessor}{#define DT 0.1}
\end{DoxyCode}
 \begin{DoxyNote}{Note}
All provided examples and pre-\/defined model elements in Ge\+N\+N work with units of m\+V, ms, n\+F and mu\+S. However, the choice of units is entirely left to the user if custom model elements are used.
\end{DoxyNote}
b) The Ge\+N\+N files {\ttfamily \hyperlink{modelSpec_8h}{model\+Spec.\+h}} and {\ttfamily \hyperlink{modelSpec_8cc}{model\+Spec.\+cc}} need to be included, 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "\hyperlink{modelSpec_8h}{modelSpec.h}"}
\textcolor{preprocessor}{#include "\hyperlink{modelSpec_8cc}{modelSpec.cc}"}
\end{DoxyCode}
 c) The values for initial variables and parameters for neuron and synapse populations need to be defined, e.\+g. 
\begin{DoxyCode}
\textcolor{keywordtype}{float} \hyperlink{tmp_2model_2MBody__userdef_8cc_aa8fe3267f630659c3634841347ae2e09}{myPOI\_p}[4]= \{
  0.1,        \textcolor{comment}{// 0 - firing rate}
  2.5,        \textcolor{comment}{// 1 - refratory period}
  20.0,       \textcolor{comment}{// 2 - Vspike}
  -60.0       \textcolor{comment}{// 3 - Vrest}
\};
\end{DoxyCode}
 would define the (homogeneous) parameters for a population of Poisson neurons. \begin{DoxyNote}{Note}
The number of required parameters and their meaning is defined by the neuron or synapse type. Refer to the \hyperlink{UserManual}{User Manual} for details. ~\newline
 If heterogeneous parameter values are needed for any particular population of neurons (synapses), a new neuron (synapse) type needs to be defined in which these parameters are defined as variables rather than parameters. See the \hyperlink{UserManual}{User Manual} for how to define new neuron (synapse) types.
\end{DoxyNote}
d) the actual network needs to be defined in the form of a function {\ttfamily model\+Definition}, i.\+e. 
\begin{DoxyCode}
\textcolor{keywordtype}{void} \hyperlink{tmp_2model_2MBody__userdef_8cc_a9aeaa0a22980484b2c472564fc9f686e}{modelDefinition}(\hyperlink{classNNmodel}{NNmodel} &model); 
\end{DoxyCode}
 \begin{DoxyNote}{Note}
The name {\ttfamily model\+Definition} and its parameter of type {\ttfamily \hyperlink{classNNmodel}{N\+Nmodel}\&} are fixed and cannot be changed if Ge\+N\+N is to recognise it as a model definition.
\end{DoxyNote}
{\ttfamily M\+Body1.\+cc} shows a typical example of a model definition function. In its core tt contains calls to {\ttfamily model.\+add\+Neuron\+Population} and {\ttfamily model.\+add\+Synapse\+Population} to build up the network. For a full range of options for defining a network, refer to the \hyperlink{UserManual}{User Manual}.
\item The programmer defines her own \char`\"{}user-\/side\char`\"{} modeling code similar to the code in {\ttfamily userproject/\+M\+Body1\+\_\+project/model/map\+\_\+classol.$\ast$} and {\ttfamily userproject/\+M\+Body1\+\_\+project/model/classol\+\_\+sim.$\ast$}. In this code,

a) she defines the connectivity matrices between neuron groups. (In the M\+Body1 example those are read from files). Refer to the \hyperlink{UserManual}{User Manual} for the required format of connectivity matrices for dense or sparse connectivities.

b) she defines input patterns (e.\+g. for Poisson neurons like in the M\+Body1 example) or individual initial values for neuron and/or synapse variables. \begin{DoxyNote}{Note}
The initial values given in the {\ttfamily model\+Definition} are automatically applied homogeneously to every individual neuron or synapse in each of the neuron or synapse groups.
\end{DoxyNote}
c) she uses {\ttfamily step\+Time\+G\+P\+U(...);} to run one time step on the G\+P\+U or {\ttfamily step\+Time\+C\+P\+U(...);} to run one on the C\+P\+U. (both G\+P\+U and C\+P\+U versions are always compiled). \begin{DoxyNote}{Note}
However, mixing C\+P\+U and G\+P\+U execution does not make too much sense. Among pother things, The C\+P\+U version uses the same host side memory whereto results from the G\+P\+U version are copied, which would lead to collisions between what is calculated on the C\+P\+U and on the G\+P\+U (see next point). However, in certain circumstances, expert users may want to split the calculation and calculate parts (e.\+g. neurons) on the G\+P\+U and parts (e.\+g. synapses) on the C\+P\+U. In such cases the fundamental kernel and function calls contained in {\ttfamily step\+Time\+X\+X\+X} need to be used and appropriate copies of the data from teh C\+P\+U to the G\+P\+U and vice versa need to be performed.
\end{DoxyNote}
d) she uses functions like {\ttfamily copy\+State\+From\+Device()} etc to transfer the results from G\+P\+U calculations to the main memory of the host computer for further processing.

e) she analyzes the results. In the most simple case this could just be writing the relevant data to output files.
\end{DoxyEnumerate}

~\newline
 

 \hyperlink{Installation}{Previous} $\vert$ \hyperlink{Quickstart}{Top} $\vert$ \hyperlink{Examples}{Next} 