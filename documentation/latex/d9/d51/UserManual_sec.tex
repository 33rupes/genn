\hypertarget{UserManual_sec_sIntro}{}\section{Introduction}\label{UserManual_sec_sIntro}
Ge\+N\+N is a software library for facilitating the simulation of neuronal network models on N\+V\+I\+D\+I\+A C\+U\+D\+A enabled G\+P\+U hardware. It was designed with computational neuroscience models in mind rather than artificial neural networks. The main philosophy of Ge\+N\+N is two-\/fold\+:
\begin{DoxyItemize}
\item Ge\+N\+N relies heavily on code generation to make it very flexible and allow adjusting simulation code to the model of interest and the G\+P\+U hardware that is detected at compile time.
\item Ge\+N\+N is lightweight in that it provides code for running models of neuronal networks on G\+P\+U hardware but it leaves it to the user to write a final simulation engine. It so allows maximal flexibility to the user who can use any of the provided code but can fully choose, inspect, extend or otherwise modify the generated code. She can also introduce her own optimisations and in particular control the data flow from and to the G\+P\+U in any desired granularity.
\end{DoxyItemize}

This User guide gives an overview of how to use Ge\+N\+N for a novice user and tries to lead the user to more expert use later on. With this we jump right in.\hypertarget{UserManual_sec_sect1}{}\section{Defining a network model}\label{UserManual_sec_sect1}
A network model is defined by the user by providing the function 
\begin{DoxyCode}
\textcolor{keywordtype}{void} \hyperlink{tmp_2model_2MBody__userdef_8cc_a9aeaa0a22980484b2c472564fc9f686e}{modelDefinition}(\hyperlink{classNNmodel}{NNmodel} &model) 
\end{DoxyCode}
 In this function, the following tasks must be completed\+:
\begin{DoxyItemize}
\item The name of the model must be defined\+: 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a757eff2a5877688e6e5492726df035ee}{setName}(\textcolor{stringliteral}{"MyModel"});
\end{DoxyCode}

\item neuron populations (at least one) must be added (see \hyperlink{UserManual_sec_subsect11}{Defining neuron populations}). The user may add as many neuron populations as she wishes. If resources run out, there will not be a warning but Ge\+N\+N will fail. All populations should have a unique name.
\item synapse populations (at least one) must be added (see \hyperlink{UserManual_sec_subsect12}{Defining synapse populations}). Again, the number of synaptic connection populations is unlimited other than by resources.
\end{DoxyItemize}\hypertarget{UserManual_sec_subsect11}{}\subsection{Defining neuron populations}\label{UserManual_sec_subsect11}
Neuron populations are added using the function 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a24532739d3ae98da3e00a9fe5aadd54e}{addNeuronPopulation}(\textcolor{stringliteral}{"name"}, n, TYPE, para, ini);
\end{DoxyCode}
 where the arguments are\+: \begin{DoxyItemize}
\item {\ttfamily const} {\ttfamily char$\ast$} name\+: Name of the neuron population \item {\ttfamily int} n\+: number of neurons in the population \item {\ttfamily int} T\+Y\+P\+E\+: Type of the neurons, refers to either a standard type (see \hyperlink{UserManual_sec_sect2}{Neuron models}) or user-\/defined type \item {\ttfamily float} $\ast$para\+: Parameters of this neuron type \item {\ttfamily float} $\ast$ini\+: Initial values for variables of this neuron type\end{DoxyItemize}
The user may add as many neuron populations as the model necessitates. They should all have unique names.\hypertarget{UserManual_sec_subsect12}{}\subsection{Defining synapse populations}\label{UserManual_sec_subsect12}
Synapse populations are added with the command 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a9dceb36a7d36c82adfdb5642df8f25f7}{addSynapsePopulation}(\textcolor{stringliteral}{"name"}, sType, sConn, gType, delaySteps, postSyn, \textcolor{stringliteral}{"preName"},
       \textcolor{stringliteral}{"postName"}, sParam, VpostSyn,PpostSyn);
\end{DoxyCode}
 where the arguments are \begin{DoxyItemize}
\item {\ttfamily const} {\ttfamily char$\ast$} name\+: The name of the synapse population \item {\ttfamily int} {\ttfamily s\+Type\+:} The type of synapse to be added (i.\+e. learning mode). See \hyperlink{UserManual_sec_subsect31}{Models} below for the available predefined synapse types. \item {\ttfamily int} {\ttfamily s\+Conn\+:} The type of synaptic connectivity. the options currently are \char`\"{}\+A\+L\+L\+T\+O\+A\+L\+L\char`\"{}, \char`\"{}\+D\+E\+N\+S\+E\char`\"{}, \char`\"{}\+S\+P\+A\+R\+S\+E\char`\"{} (see \hyperlink{UserManual_sec_subsect32}{Connectivity types} ) \item {\ttfamily int} {\ttfamily g\+Type\+:} The way how the synaptic conductivity g will be defined. Options are \char`\"{}\+I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+G\char`\"{}, \char`\"{}\+G\+L\+O\+B\+A\+L\+G\char`\"{}, \char`\"{}\+I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+I\+D\char`\"{}. For their meaning, see \hyperlink{UserManual_sec_subsect33}{Conductance definition methods} below. \item {\ttfamily int} {\ttfamily delay\+Steps\+:} Number of delay slots. \item {\ttfamily int} {\ttfamily post\+Syn\+:} Postsynaptic integration method. See \hyperlink{UserManual_sec_sect_postsyn}{Post-\/synaptic integration methods} for predefined types. \item {\ttfamily char$\ast$} {\ttfamily pre\+Name\+:} Name of the (existing!) per-\/synaptic neuron population. \item {\ttfamily char$\ast$} {\ttfamily post\+Name\+:} Name of the (existing!) post-\/synaptic neuron population. \item {\ttfamily float$\ast$} {\ttfamily s\+Param\+:} A C-\/type array of floats that contains parameter values (common to all synapses of the population) which will be used for the defined synapses. The array must contain the right number of parameters in the right order for the chosen synapse type. If too few, segmentation faults will occur, if too many, excess will be ignored.\end{DoxyItemize}
Warnings\+: 1. If the synapse conductance definition type is \char`\"{}\+G\+L\+O\+B\+A\+L\+G\char`\"{} the global value of the synapse conductances must be set with set\+Synapse\+G().

Synaptic update can be done by using true spikes (one point per spike after the threshold) or by using spike events (all points above the threshold).\hypertarget{UserManual_sec_sect2}{}\section{Neuron models}\label{UserManual_sec_sect2}
There is a number of predefined models which can be chosen in the {\ttfamily add\+Neuron\+Group} function by their unique cardinal number, starting from 0. For convenience, C constants with readable names are predefined\+:
\begin{DoxyItemize}
\item 0\+: \hyperlink{UserManual_sec_sect21}{M\+A\+P\+N\+E\+U\+R\+O\+N}
\item 1\+: \hyperlink{UserManual_sec_sect22}{P\+O\+I\+S\+S\+O\+N\+N\+E\+U\+R\+O\+N}
\item 2\+: \hyperlink{UserManual_sec_sect23}{T\+R\+A\+U\+B\+M\+I\+L\+E\+S}
\item 3\+: \hyperlink{UserManual_sec_sect24}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H}
\item 4\+: \hyperlink{UserManual_sec_sect25}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H\+\_\+\+V}
\end{DoxyItemize}\hypertarget{UserManual_sec_sect21}{}\subsection{M\+A\+P\+N\+E\+U\+R\+O\+N (\+Map Neurons)}\label{UserManual_sec_sect21}
The M\+A\+P\+N\+E\+U\+R\+O\+N type is a map based neuron model as defined in \cite{Rulkov2002} .

It has 2 variables\+:
\begin{DoxyItemize}
\item {\ttfamily V} -\/ the membrane potential
\item {\ttfamily pre\+V} -\/ the membrane potential at the previous time step
\end{DoxyItemize}

and it has 4 parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Vspike} -\/ the membrane potential at the top of the spike
\item {\ttfamily alpha} -\/ determines the shape of the iteration function
\item {\ttfamily y} -\/ \char`\"{}shift / excitation\char`\"{} parameter, also determines the iteration function
\item {\ttfamily beta} -\/ roughly regulates the scale of the input into the neuron
\end{DoxyItemize}\hypertarget{UserManual_sec_sect22}{}\subsection{P\+O\+I\+S\+S\+O\+N\+N\+E\+U\+R\+O\+N (\+Poisson Neurons)}\label{UserManual_sec_sect22}
Poisson neurons have constant membrane potential ({\ttfamily Vrest}) unless they are activated randomly to the {\ttfamily Vspike} value if (t-\/ {\ttfamily Spike\+Time} ) $>$ {\ttfamily trefract}.

It has 3 variables\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ Membrane potential
\item {\ttfamily Seed} -\/ Seed for random number generation
\item {\ttfamily Spike\+Time} -\/ Time at which the neuron spiked for the last time
\end{DoxyItemize}

and 4 parameters\+:


\begin{DoxyItemize}
\item {\ttfamily therate} -\/ Firing rate
\item {\ttfamily trefract} -\/ Refractory period
\item {\ttfamily Vspike} -\/ Membrane potential at spike (m\+V)
\item {\ttfamily Vrest} -\/ Membrane potential at rest (m\+V)
\end{DoxyItemize}\hypertarget{UserManual_sec_sect23}{}\subsection{T\+R\+A\+U\+B\+M\+I\+L\+E\+S (\+Hodgkin-\/\+Huxley neurons with Traub \& Miles algorithm)}\label{UserManual_sec_sect23}
It has 4 variables\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ membrane potential E
\item {\ttfamily m} -\/ probability for Na channel activation m
\item {\ttfamily h} -\/ probability for not Na channel blocking h
\item {\ttfamily n} -\/ probability for K channel activation n
\end{DoxyItemize}

and 7 parameters\+:


\begin{DoxyItemize}
\item {\ttfamily g\+Na} -\/ Na conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily E\+Na} -\/ Na equi potential in m\+V
\item {\ttfamily g\+K} -\/ K conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily E\+K} -\/ K equi potential in m\+V
\item {\ttfamily gl} -\/ Leak conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily El} -\/ Leak equi potential in m\+V
\item {\ttfamily Cmem} -\/ Membrane capacity density in mu\+F/cm$^\wedge$2
\end{DoxyItemize}\hypertarget{UserManual_sec_sect24}{}\subsection{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H (\+Izhikevich neurons with fixed parameters)}\label{UserManual_sec_sect24}
This is the Izhikevich model with fixed parameters \cite{izhikevich2003simple}.

Variables are\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ Membrane potential
\item {\ttfamily U} -\/ Membrane recovery variable
\end{DoxyItemize}

Parameters are\+:
\begin{DoxyItemize}
\item {\ttfamily a} -\/ time scale of U
\item {\ttfamily b} -\/ sensitivity of U
\item {\ttfamily c} -\/ after-\/spike reset value of V
\item {\ttfamily d} -\/ after-\/spike reset value of U
\end{DoxyItemize}\hypertarget{UserManual_sec_sect25}{}\subsection{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H\+\_\+\+V (\+Izhikevich neurons with variable parameters)}\label{UserManual_sec_sect25}
This is the same model as \hyperlink{UserManual_sec_sect24}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H (Izhikevich neurons with fixed parameters)} I\+Z\+H\+I\+K\+E\+V\+I\+C\+H but parameters defined as variables in order to provide a parameter range instead of fixed values for every neuron in the population.\hypertarget{UserManual_sec_sect_own}{}\subsection{Defining your own neuron model}\label{UserManual_sec_sect_own}
In order to define a new neuron model for use in a Ge\+N\+N application, it is necessary to populate an object of class {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} and append it to the global vector {\ttfamily n\+Models}. The {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} class has several data members that make up the full description of the neuron model\+:


\begin{DoxyItemize}
\item {\ttfamily sim\+Code} of type {\ttfamily string\+:} This needs to be assigned a C++ string that contains the code for executing the integration of the model for one time step. Within this code string, variables need to be referred to by , where N\+A\+M\+E is the name of the variable as defined in the vector var\+Names. The code may refer to the predefined primitives \char`\"{}\+D\+T\char`\"{} for the time step size and \char`\"{}\+Isyn\char`\"{} for the total incoming synaptic current.
\item {\ttfamily var\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector needs to be filled with the names of variables that make up the neuron state. The variables defined here as \char`\"{}\+N\+A\+M\+E\char`\"{} can then be used in the syntax  in the code string.
\item {\ttfamily var\+Types} of type {\ttfamily vector$<$string$>$}\+: This vector needs to be filled with the variable type (e.\+g. \char`\"{}float\char`\"{}, \char`\"{}double\char`\"{}, etc) for the variables defined in {\ttfamily var\+Names}. Types and variables are matched to each other by position in the respective vectors.
\item {\ttfamily p\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector will contain the names of parameters relevant to the model. If defined as \char`\"{}\+N\+A\+M\+E\char`\"{} here, they can then be referenced as \char`\"{}\$(\+N\+A\+M\+E)\char`\"{} in the code string. The length of this vector determines the expected number of parameters in the initialisation of the neuron model. Parameters are currently assumed to be always of type float.
\item {\ttfamily dp\+Names} of type {\ttfamily vector$<$string$>$}\+: Names of dependant parameters. This is a mechanism for enhanced efficiency for running neuron models. If parameters with model-\/side meaning, such as time constants or conductances always appear in a certain combination in the model, then it is more efficient to pre-\/compute the combination and define it as a dependent parameter. This vector contains the names of such dependent parameters.
\item {\ttfamily tmp\+Var\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector can be used to request additional variables that are not part of the state of the neuron but used only as temporary storage during evaluation of the integration time step.
\item {\ttfamily tmp\+Var\+Types} of type {\ttfamily vector$<$string$>$}\+: This vector will contain the variable types of the temporary variables.
\end{DoxyItemize}

Once the completed {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} object is appended to the {\ttfamily n\+Models} vector it can be used in network descriptions by referring to its cardinal number in the n\+Models vector. I.\+e., if the model is added as the 4th entry, it would be model \char`\"{}3\char`\"{} (counting starts at 0 in usual C convention). The information of the cardinal number of a new model can be obtained by referring to {\ttfamily n\+Models.\+size()} right before appending the new model.

For dependent parameters in a user-\/defined model, it is the user's responsibility to intitialize the derived parameters from the relevant entries of the global {\ttfamily neuron\+Para} vector entries, to store them in a vector and append this vector to the global vector {\ttfamily dnp}. This needs to be done right after the call to add\+Neuron\+Population that involves the neuron model in questions. For an example of what needs to be done, refer to the member function {\ttfamily init\+Derived\+Neuron\+Para()} of class {\ttfamily \hyperlink{classNNmodel}{N\+Nmodel}} which does this for Rulkov map neurons.\hypertarget{UserManual_sec_sect_explinput}{}\section{Explicit current input to neurons}\label{UserManual_sec_sect_explinput}
The user can decide whether a neuron group receives external input current or not in addition to the synaptic input that it receives from the network. External input to a neuron group is activated by calling {\ttfamily activate\+Direct\+Input} function. It receives two arguments\+: The first argument is the name of the neuron group to receive input current. The second parameter defines the type of input. Current options are\+:


\begin{DoxyItemize}
\item 0\+: N\+O\+I\+N\+P\+: Neuron group receives no input. This is the value by default when the explicit input is not activated.
\item 1\+: C\+O\+N\+S\+T\+I\+N\+P\+: All the neurons receive a constant input value. This value may also be defined as a variable.
\item 2\+: M\+A\+T\+I\+N\+P\+: Input is read from a file containing the input matrix.
\item 3\+: I\+N\+P\+R\+U\+L\+E\+: Input is defined as a rule. It differs from C\+O\+N\+S\+T\+I\+N\+P by the way that the input is injected\+: C\+O\+N\+S\+T\+I\+N\+P creates a value which is modified in real time, hence complex instructions are limited. I\+N\+P\+R\+U\+L\+E creates an input array which will be copied into the device memory.
\end{DoxyItemize}\hypertarget{UserManual_sec_sect3}{}\section{Synapse models}\label{UserManual_sec_sect3}
\hypertarget{UserManual_sec_subsect31}{}\subsection{Models}\label{UserManual_sec_subsect31}
Currently 3 predefined synapse models are available\+:
\begin{DoxyItemize}
\item 0\+: \hyperlink{UserManual_sec_sect31}{N\+S\+Y\+N\+A\+P\+S\+E}
\item 1\+: \hyperlink{UserManual_sec_sect32}{N\+G\+R\+A\+D\+S\+Y\+N\+A\+P\+S\+E}
\item 2\+: \hyperlink{UserManual_sec_sect33}{L\+E\+A\+R\+N1\+S\+Y\+N\+A\+P\+S\+E}
\end{DoxyItemize}\hypertarget{UserManual_sec_sect31}{}\subsubsection{N\+S\+Y\+N\+A\+P\+S\+E (\+No Learning)}\label{UserManual_sec_sect31}
If this model is selected, no learning rule is applied to the synapse. The model has 3 parameters\+:
\begin{DoxyItemize}
\item {\ttfamily tau\+\_\+\+S$\ast$} -\/ decay time constant for S \mbox{[}ms\mbox{]}
\item {\ttfamily Epre\+:} Presynaptic threshold potential
\item {\ttfamily Erev$\ast$} -\/ Reversal potential
\end{DoxyItemize}

($\ast$ D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+: Decay time constant and reversal potential in synapse parameters are not used anymore and they will be removed in the next release. They should be defined in the postsynaptic mechanisms.)\hypertarget{UserManual_sec_sect32}{}\subsubsection{N\+G\+R\+A\+D\+S\+Y\+N\+A\+P\+S\+E (\+Graded Synapse)}\label{UserManual_sec_sect32}
In a graded synapse, the conductance is updated gradually with the rule\+:

\[ gSyn= g * tanh((E - E_{pre}) / V_{slope} \]

The parameters are\+:
\begin{DoxyItemize}
\item {\ttfamily Erev$\ast$}\+: Reversal potential
\item {\ttfamily Epre\+:} Presynaptic threshold potential
\item {\ttfamily tau\+\_\+\+S$\ast$}\+: Decay time constant for S \mbox{[}ms\mbox{]}
\item {\ttfamily Vslope\+:} Activation slope of graded release
\end{DoxyItemize}

($\ast$ D\+E\+P\+R\+E\+C\+A\+T\+E\+D\+: Decay time constant and reversal potential in synapse parameters are not used anymore and they will be removed in the next release. They should be defined in the postsynaptic mechanisms.)\hypertarget{UserManual_sec_sect33}{}\subsubsection{L\+E\+A\+R\+N1\+S\+Y\+N\+A\+P\+S\+E (\+Learning Synapse with a Primitive Role)}\label{UserManual_sec_sect33}
This is a simple S\+T\+D\+P rule including a time delay for the finite transmission speed of the synapse, defined as a piecewise function.

This model has 13 parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Erev\+:} Reversal potential
\item {\ttfamily Epre\+:} Presynaptic threshold potential
\item {\ttfamily tau\+\_\+\+S\+:} Decay time constant for S \mbox{[}ms\mbox{]}
\item {\ttfamily T\+L\+R\+N\+:} Time scale of learning changes
\item {\ttfamily T\+C\+H\+N\+G\+:} Width of learning window
\item {\ttfamily T\+D\+E\+C\+A\+Y\+:} Time scale of synaptic strength decay
\item {\ttfamily T\+P\+U\+N\+I\+S\+H10\+:} Time window of suppression in response to 1/0
\item {\ttfamily T\+P\+U\+N\+I\+S\+H01\+:} Time window of suppression in response to 0/1
\item {\ttfamily G\+M\+A\+X\+:} Maximal conductance achievable
\item {\ttfamily G\+M\+I\+D\+:} Midpoint of sigmoid g filter curve
\item {\ttfamily G\+S\+L\+O\+P\+E\+:} Slope of sigmoid g filter curve
\item {\ttfamily T\+A\+U\+S\+Hi\+F\+T\+:} Shift of learning curve
\item {\ttfamily G\+S\+Y\+N0\+:} Value of syn conductance g decays to
\end{DoxyItemize}

For more details, see \cite{nowotny2005self}.\hypertarget{UserManual_sec_sect34}{}\subsubsection{Defining a new synapse model}\label{UserManual_sec_sect34}
There is a way to define a synapse model the same way a \hyperlink{structneuronModel}{neuron\+Model} can be defined. This feature is still experimental and supported only with the Spine\+M\+L and development branches.

A synapse model is a \hyperlink{classweightUpdateModel}{weight\+Update\+Model} object which consists of variables, parameters, and three string objects which will be substituted in the code. These three strings are\+:


\begin{DoxyItemize}
\item {\ttfamily sim\+Code\+:} Simulation code that is used when a true spike is detected (only one point after Vthresh)
\item {\ttfamily sim\+Code\+Evnt\+:} Simulation code that is used for spike events (all the instances where Vm $>$ Vthres)
\item {\ttfamily sim\+Learn\+Post\+:} Simulation code which is used in the learn\+Synapses\+Post kernel/function, where postsynaptic neuron spikes before the presynaptic neuron in the S\+T\+D\+P window. Usually this is simply the conductance update rule defined by the other sim\+Code elements above, with negative timing. This code is needed as sim\+Code and sim\+Code\+Envt are used after spanning the presynaptic spikes, where it is not possible to detect where a postsynaptic neuron fired before the presynaptic neuron.
\end{DoxyItemize}

These codes would include update functions for adding up conductances for that neuron model and for changes in conductances for the next time step (learning). Condutance in this code should be referred to as \$(\char`\"{}\+G\char`\"{})\hypertarget{UserManual_sec_subsect32}{}\subsection{Connectivity types}\label{UserManual_sec_subsect32}
If I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+G is used with A\+L\+L\+T\+O\+A\+L\+L connectivity, the conductance values are stored in an array called \char`\"{}ftype $\ast$ gp$<$synapse\+Name$>$\char`\"{}, defined and initialised in runner.\+cc in the generated code.

If I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+I\+D is used with A\+L\+L\+T\+O\+A\+L\+L connectivity, the connectivity matrix is stored in an array called \char`\"{}unsigned int $\ast$ gp$<$synapse\+Name$>$\char`\"{}

If connectivity is of S\+P\+A\+R\+S\+E type, connectivity and conductance values are stored in a struct in order to occupy minimum memory needed. The struct Conductance contains 3 array members and one integer member\+: 1\+: unsigned int conn\+N\+: number of connections in the population. This value is needed for allocaton of arrays. 2\+: floattype $\ast$ gp\+: Values of conductances. The indices that correspond to these values are defined in a pre-\/to-\/post basis by the following arrays\+: 4\+: unsigned int g\+Ind, of size conn\+N\+: Indices of corresponding postsynaptic neurons concatenated for each presynaptic neuron. 3\+: unsigned int $\ast$g\+Ind\+In\+G, of size model.\+neuron\+N\mbox{[}model.\+synapse\+Source\mbox{[}syn\+Ind\mbox{]}\mbox{]}+1\+: This array defines from which index in the gp array the indices in g\+Ind would correspond to the presynaptic neuron that corresponds to the index of the g\+Ind\+In\+G array, with the number of connections being the size of g\+Ind. More specifically, g\+Ind\+Ing\mbox{[}n+1\mbox{]}-\/g\+Ind\+Ing\mbox{[}n\mbox{]} would give the number of postsynaptic connections for neuron n, and the conductance values are stored in gp\mbox{[}g\+Ind\+Ing\mbox{[}n\mbox{]}\mbox{]} to gp\mbox{[}g\+Ind\+Ing\mbox{[}n\mbox{]}+1\mbox{]}. if there are no connections for a presynaptic neuron, then gp\mbox{[}g\+Ind\+Ing\mbox{[}n\mbox{]}\mbox{]}=gp\mbox{[}g\+Ind\+Ing\mbox{[}n\mbox{]}+1\mbox{]}.

For example, consider a network of two presynaptic neurons connected to three postsynaptic neurons\+: 0th presynaptic neuron connected to 1st and 2nd postsynaptic neurons, the 1st presynaptic neuron connected to 0th and 2nd neurons. The struct Conductance should have these members, with indexing from 0\+: Conn\+N = 4 gp= g\+Pre0-\/\+Post1 gpre0-\/post2 gpre1-\/post0 gpre1-\/post2 g\+Ind= 1 2 0 2 g\+Ind\+Ing= 0 2 4

See tools/gen\+\_\+syns\+\_\+sparse\+\_\+\+Izh\+Model used in Izh\+\_\+sparse project to see a working example.\hypertarget{UserManual_sec_subsect33}{}\subsection{Conductance definition methods}\label{UserManual_sec_subsect33}
The available options work as follows\+:
\begin{DoxyItemize}
\item I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+G\+: When this option is chosen in the {\ttfamily add\+Synapse\+Population} command, Ge\+N\+N reserves an array of size n\+\_\+pre x n\+\_\+post float for individual conductance values for each combination of pre and postsynaptic neuron. The actual values of teh conductances are passed at runtime from the user side code, using the {\ttfamily copy\+G\+To\+Device} function.
\item G\+L\+O\+B\+A\+L\+G\+: When this option is chosen, the {\ttfamily add\+Synapse\+Population} command must be followed within the {\ttfamily model\+Definition} function by a call to {\ttfamily set\+Synapse\+G} for this synapse population. This option can only be sensibly combined with connectivity type A\+L\+L\+T\+O\+A\+L\+L.
\item I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+I\+D\+: When this option is chosen, Ge\+N\+N expects to use the same maximal conductance for all existing synaptic connections but which synapses exist will be defined at runtime from the user side code. 
\end{DoxyItemize}\hypertarget{UserManual_sec_sect_postsyn}{}\section{Post-\/synaptic integration methods}\label{UserManual_sec_sect_postsyn}
The shape of the postsynaptic current can be defined by either using a predefined method or by adding a new \hyperlink{structpostSynModel}{post\+Syn\+Model} object.


\begin{DoxyItemize}
\item E\+X\+P\+D\+E\+C\+A\+Y\+: Exponential decay. Decay time constant and reversal potential parameters are needed for this postsynaptic mechanism. 
\end{DoxyItemize}