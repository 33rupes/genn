Ge\+N\+N is a software library for facilitating the simulation of neuronal network models on N\+V\+I\+D\+I\+A C\+U\+D\+A enabled G\+P\+U hardware. It was designed with computational neuroscience models in mind rather than artificial neural networks. The main philosophy of Ge\+N\+N is two-\/fold\+:
\begin{DoxyEnumerate}
\item Ge\+N\+N relies heavily on code generation to make it very flexible and to allow adjusting simulation code to the model of interest and the G\+P\+U hardware that is detected at compile time.
\item Ge\+N\+N is lightweight in that it provides code for running models of neuronal networks on G\+P\+U hardware but it leaves it to the user to write a final simulation engine. It so allows maximal flexibility to the user who can use any of the provided code but can fully choose, inspect, extend or otherwise modify the generated code. She can also introduce her own optimisations and in particular control the data flow from and to the G\+P\+U in any desired granularity.
\end{DoxyEnumerate}

This manual gives an overview of how to use Ge\+N\+N for a novice user and tries to lead the user to more expert use later on. With this we jump right in.

Contents

\hyperlink{sect1}{Defining a network model} Defining a network model \hyperlink{sect2}{Neuron models} Neuron models \hyperlink{sect3}{Synapse models} Synapse models \hypertarget{sect1}{}\section{Defining a network model}\label{sect1}
A network model is defined by the user by providing the function 
\begin{DoxyCode}
\textcolor{keywordtype}{void} \hyperlink{tmp_2model_2MBody__userdef_8cc_a9aeaa0a22980484b2c472564fc9f686e}{modelDefinition}(\hyperlink{classNNmodel}{NNmodel} &model) 
\end{DoxyCode}
 in a separate file with name {\ttfamily name.\+cc}, where {\ttfamily name} is the name of the model network under consideration. In this function, the following tasks must be completed\+:
\begin{DoxyEnumerate}
\item The name of the model must be defined\+: 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a757eff2a5877688e6e5492726df035ee}{setName}(\textcolor{stringliteral}{"MyModel"});
\end{DoxyCode}

\item Neuron populations (at least one) must be added (see \hyperlink{sect1_subsect11}{Defining neuron populations}). The user may add as many neuron populations as she wishes. If resources run out, there will not be a warning but Ge\+N\+N will fail. However, before this breaking point is reached, Ge\+N\+N will make all necessary efforts in terms of block size optimisation to accommodate the defined models. All populations should have a unique name.
\item Synapse populations (zero or more) can be added (see \hyperlink{sect1_subsect12}{Defining synapse populations}). Again, the number of synaptic connection populations is unlimited other than by resources.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
Ge\+N\+N uses the convention where C/\+C++ files end in {\ttfamily .cc}. If this is not adhered to the build script {\ttfamily buildmodel.\+sh} will not recognise the model definition file.
\end{DoxyNote}
\hypertarget{sect1_subsect11}{}\subsection{Defining neuron populations}\label{sect1_subsect11}
Neuron populations are added using the function 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a24532739d3ae98da3e00a9fe5aadd54e}{addNeuronPopulation}(name, n, TYPE, para, ini);
\end{DoxyCode}
 where the arguments are\+: \begin{DoxyItemize}
\item {\ttfamily const} {\ttfamily char$\ast$} name\+: Name of the neuron population \item {\ttfamily int} n\+: number of neurons in the population \item {\ttfamily int} T\+Y\+P\+E\+: Type of the neurons, refers to either a standard type (see \hyperlink{sect2}{Neuron models}) or user-\/defined type \item {\ttfamily float} $\ast$para\+: Parameters of this neuron type \item {\ttfamily float} $\ast$ini\+: Initial values for variables of this neuron type\end{DoxyItemize}
The user may add as many neuron populations as the model necessitates. They should all have unique names. The possible values for the arguments, predefined models and their parameters and initial values are detailed \hyperlink{sect2}{Neuron models} below.\hypertarget{sect1_subsect12}{}\subsection{Defining synapse populations}\label{sect1_subsect12}
Synapse populations are added with the command 
\begin{DoxyCode}
model.\hyperlink{classNNmodel_a9dceb36a7d36c82adfdb5642df8f25f7}{addSynapsePopulation}(\textcolor{stringliteral}{"name"}, sType, sConn, gType, delay, postSyn, \textcolor{stringliteral}{"preName"}, \textcolor{stringliteral}{"
      postName"}, sIni, sParam, postSynIni, postSynParam);
\end{DoxyCode}
 where the arguments are \begin{DoxyItemize}
\item {\ttfamily const} {\ttfamily char$\ast$} name\+: The name of the synapse population \item {\ttfamily int} {\ttfamily s\+Type\+:} The type of synapse to be added. See \hyperlink{sect3_subsect31}{Models} below for the available predefined synapse types. \item {\ttfamily int} {\ttfamily s\+Conn\+:} The type of synaptic connectivity. the options currently are \char`\"{}\+A\+L\+L\+T\+O\+A\+L\+L\char`\"{}, \char`\"{}\+D\+E\+N\+S\+E\char`\"{}, \char`\"{}\+S\+P\+A\+R\+S\+E\char`\"{} (see \hyperlink{sect3_subsect32}{Connectivity types} ) \item {\ttfamily int} {\ttfamily g\+Type\+:} The way how the synaptic conductivity g will be defined. Options are \char`\"{}\+I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+G\char`\"{}, \char`\"{}\+G\+L\+O\+B\+A\+L\+G\char`\"{}, \char`\"{}\+I\+N\+D\+I\+V\+I\+D\+U\+A\+L\+I\+D\char`\"{}. For their meaning, see \hyperlink{sect3_subsect33}{Conductance definition methods} below. \item {\ttfamily int} {\ttfamily delay\+:} Synaptic delay (in multiples of the simulation time step {\ttfamily D\+T}). \item {\ttfamily int} {\ttfamily post\+Syn\+:} Postsynaptic integration method. See \hyperlink{sect_postsyn}{Post-\/synaptic integration methods} for predefined types. \item {\ttfamily char$\ast$} {\ttfamily pre\+Name\+:} Name of the (existing!) pre-\/synaptic neuron population. \item {\ttfamily char$\ast$} {\ttfamily post\+Name\+:} Name of the (existing!) post-\/synaptic neuron population. \item {\ttfamily float$\ast$} {\ttfamily s\+Ini\+:} A C-\/array of floats containing initial values for the (pre-\/) synaptic variables. \item {\ttfamily float$\ast$} {\ttfamily s\+Param\+:} A C-\/array of floats that contains parameter values (common to all synapses of the population) which will be used for the defined synapses. The array must contain the right number of parameters in the right order for the chosen synapse type. If too few, segmentation faults will occur, if too many, excess will be ignored. For pre-\/defined synapse types the required parameters and their meaning are listed in \hyperlink{sect3_sect31}{N\+S\+Y\+N\+A\+P\+S\+E (No Learning)} below.\end{DoxyItemize}
\begin{DoxyNote}{Note}
If the synapse conductance definition type is \char`\"{}\+G\+L\+O\+B\+A\+L\+G\char`\"{} then the global value of the synapse conductances is taken from the initial value provided in {\ttfamily s\+I\+N\+I}. (The function set\+Synapse\+G() from earlier versions of Ge\+N\+N has been deprecated).
\end{DoxyNote}
Synaptic updates can occur per \char`\"{}true\char`\"{} spike (i.\+e at one point per spike, e.\+g. after a threshold was crossed) or for all \char`\"{}spike type events\char`\"{} (e.\+g. all points above a given threshold). This is defined within each given synapse type. \hypertarget{sect2}{}\section{Neuron models}\label{sect2}
There is a number of predefined models which can be chosen in the {\ttfamily add\+Neuron\+Group}(...) function by their unique cardinal number, starting from 0. For convenience, C variables with readable names are predefined
\begin{DoxyItemize}
\item 0\+: \hyperlink{sect2_sect21}{M\+A\+P\+N\+E\+U\+R\+O\+N}
\item 1\+: \hyperlink{sect2_sect22}{P\+O\+I\+S\+S\+O\+N\+N\+E\+U\+R\+O\+N}
\item 2\+: \hyperlink{sect2_sect23}{T\+R\+A\+U\+B\+M\+I\+L\+E\+S}
\item 3\+: \hyperlink{sect2_sect24}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H}
\item 4\+: \hyperlink{sect2_sect25}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H\+\_\+\+V}
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Ist is best practice to not depend on the unique cardinal numbers but use predefined names. While it is not intended that the numbers will change the unique names are guaranteed to work in all future versions of Ge\+N\+N.
\end{DoxyNote}
\hypertarget{sect2_sect21}{}\subsection{M\+A\+P\+N\+E\+U\+R\+O\+N (\+Map Neurons)}\label{sect2_sect21}
The M\+A\+P\+N\+E\+U\+R\+O\+N type is a map based neuron model based on \cite{Rulkov2002} but in the 1-\/dimensional map form used in \cite{nowotny2005self} \+: \begin{eqnarray*} V(t+\Delta t) &=& \left\{ \begin{array}{ll} V_{\rm spike} \Big(\frac{\alpha V_{\rm spike}}{V_{\rm spike}-V(t) \beta I_{\rm syn}} + y \Big) & V(t) \leq 0 \\ V_{\rm spike} \big(\alpha+y\big) & V(t) \leq V_{\rm spike} \big(\alpha + y\big) \; \& \; V(t-\Delta t) \leq 0 \\ -V_{\rm spike} & {\rm otherwise} \end{array} \right. \end{eqnarray*} \begin{DoxyNote}{Note}
The {\ttfamily M\+A\+P\+N\+E\+U\+R\+O\+N} type only works as intended for the single time step size of {\ttfamily D\+T}= 0.\+5.
\end{DoxyNote}
The {\ttfamily M\+A\+P\+N\+E\+U\+R\+O\+N} type has 2 variables\+:
\begin{DoxyItemize}
\item {\ttfamily V} -\/ the membrane potential
\item {\ttfamily pre\+V} -\/ the membrane potential at the previous time step
\end{DoxyItemize}

and it has 4 parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Vspike} -\/ determines the amplitude of spikes, typically -\/60m\+V
\item {\ttfamily alpha} -\/ determines the shape of the iteration function, typically $\alpha $= 3
\item {\ttfamily y} -\/ \char`\"{}shift / excitation\char`\"{} parameter, also determines the iteration function,originally, y= -\/2.\+468
\item {\ttfamily beta} -\/ roughly speaking equivalent to the input resistance, i.\+e. it regulates the scale of the input into the neuron, typically $\beta$= 2.\+64 ${\rm M}\Omega$.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
The initial values array for the {\ttfamily M\+A\+P\+N\+E\+U\+R\+O\+N} type needs two entries for {\ttfamily V} and {\ttfamily Vpre} and the parameter array needs four entries for {\ttfamily Vspike}, {\ttfamily alpha}, {\ttfamily y} and {\ttfamily beta}, {\itshape in that order}.
\end{DoxyNote}
\hypertarget{sect2_sect22}{}\subsection{P\+O\+I\+S\+S\+O\+N\+N\+E\+U\+R\+O\+N (\+Poisson Neurons)}\label{sect2_sect22}
Poisson neurons have constant membrane potential ({\ttfamily Vrest}) unless they are activated randomly to the {\ttfamily Vspike} value if (t-\/ {\ttfamily Spike\+Time} ) $>$ {\ttfamily trefract}.

It has 3 variables\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ Membrane potential
\item {\ttfamily Seed} -\/ Seed for random number generation
\item {\ttfamily Spike\+Time} -\/ Time at which the neuron spiked for the last time
\end{DoxyItemize}

and 4 parameters\+:


\begin{DoxyItemize}
\item {\ttfamily therate} -\/ Firing rate
\item {\ttfamily trefract} -\/ Refractory period
\item {\ttfamily Vspike} -\/ Membrane potential at spike (m\+V)
\item {\ttfamily Vrest} -\/ Membrane potential at rest (m\+V)
\end{DoxyItemize}

\begin{DoxyNote}{Note}
The initial values array for the {\ttfamily P\+O\+I\+S\+S\+O\+N\+N\+E\+U\+R\+O\+N} type needs three entries for {\ttfamily V}, {\ttfamily Seed} and {\ttfamily Spike\+Time} and the parameter array needs four entries for {\ttfamily therate}, {\ttfamily trefract}, {\ttfamily Vspike} and {\ttfamily Vrest}, {\itshape in that order}.

Internally, Ge\+N\+N uses a linear approximation for the probability of firing a spike in a given time step of size {\ttfamily D\+T}, i.\+e. the probability of firing is {\ttfamily therate} times {\ttfamily D\+T}\+: $ p = \lambda \Delta t $. This approximation is usually very good, especially for typical, quite small time steps and moderate firing rates. However, it is worth noting that the approximation becomes poor for very high firing rates and large time steps. An unrelated problem may occur with very low firing rates and small time steps. In that case it can occur that the firing probability is so small that the granularity of the 64 bit integer based random number generator begins to show. The effect manifests itself in that small changes in the firing rate do not seem to have an effect on the behaviour of the Poisson neurons because the numbers are so small that only if the random number is identical 0 a spike will be triggered.
\end{DoxyNote}
\hypertarget{sect2_sect23}{}\subsection{T\+R\+A\+U\+B\+M\+I\+L\+E\+S (\+Hodgkin-\/\+Huxley neurons with Traub \& Miles algorithm)}\label{sect2_sect23}
This conductance based model has been taken from Traub1991 and can be described by the equations\+: \begin{eqnarray*} C \frac{d V}{dt} &=& -I_{{\rm Na}} -I_K-I_{{\rm leak}}-I_M-I_{i,DC}-I_{i,{\rm syn}}-I_i, \\ I_{{\rm Na}}(t) &=& g_{{\rm Na}} m_i(t)^3 h_i(t)(V_i(t)-E_{{\rm Na}}) \\ I_{{\rm K}}(t) &=& g_{{\rm K}} n_i(t)^4(V_i(t)-E_{{\rm K}}) \\ \frac{dy(t)}{dt} &=& \alpha_y (V(t))(1-y(t))-\beta_y(V(t)) y(t), \end{eqnarray*} where $y_i= m, h, n$, and \begin{eqnarray*} \alpha_n&=& 0.032(-50-V)/\big(\exp((-50-V)/5)-1\big) \\ \beta_n &=& 0.5\exp((-55-V)/40) \\ \alpha_m &=& 0.32(-52-V)/\big(\exp((-52-V)/4)-1\big) \\ \beta_m &=& 0.28(25+V)/\big(\exp((25+V)/5)-1\big) \\ \alpha_h &=& 0.128\exp((-48-V)/18) \\ \beta_h &=& 4/\big(\exp((-25-V)/5)+1\big). \end{eqnarray*} and typical parameters are $C=0.143$ n\+F, $g_{{\rm leak}}= 0.02672$ $\mu$S, $E_{{\rm leak}}= -63.563$ m\+V, $g_{{\rm Na}}=7.15$ $\mu$S, $E_{{\rm Na}}= 50$ m\+V, $g_{{\rm {\rm K}}}=1.43$ $\mu$S, $E_{{\rm K}}= -95$ m\+V.

It has 4 variables\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ membrane potential E
\item {\ttfamily m} -\/ probability for Na channel activation m
\item {\ttfamily h} -\/ probability for not Na channel blocking h
\item {\ttfamily n} -\/ probability for K channel activation n
\end{DoxyItemize}

and 7 parameters\+:


\begin{DoxyItemize}
\item {\ttfamily g\+Na} -\/ Na conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily E\+Na} -\/ Na equi potential in m\+V
\item {\ttfamily g\+K} -\/ K conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily E\+K} -\/ K equi potential in m\+V
\item {\ttfamily gl} -\/ Leak conductance in 1/(m\+Ohms $\ast$ cm$^\wedge$2)
\item {\ttfamily El} -\/ Leak equi potential in m\+V
\item {\ttfamily Cmem} -\/ Membrane capacity density in mu\+F/cm$^\wedge$2
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Internally, the ordinary differential equations defining the model are integrated with a linear Euler algorithm and Ge\+N\+N integrates 25 internal time steps for each neuron for each network time step. I.\+e., if the network is simulated at {\ttfamily D\+T= 0.\+1} ms, then the neurons are integrated with a linear Euler algorithm with {\ttfamily l\+D\+T= 0.\+004} ms.
\end{DoxyNote}
\hypertarget{sect2_sect24}{}\subsection{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H (\+Izhikevich neurons with fixed parameters)}\label{sect2_sect24}
This is the Izhikevich model with fixed parameters \cite{izhikevich2003simple}. It is usually described as \begin{eqnarray*} \frac{dV}{dt} &=& 0.04 V^2 + 5 V + 140 - U + I, \\ \frac{dU}{dt} &=& a (bV-U), \end{eqnarray*} I is an external input current and the voltage V is reset to parameter c and U incremented by parameter d, whenever V $>$= 30 m\+V. This is paired with a particular integration procedure of two 0.\+5 ms Euler time steps for the V equation followed by one 1 ms time step of teh U equation. Because of its popularity we provide this model in this form here event though due to the details of the usual implementation it is strictly speaking inconsistent with the displayed equations.

Variables are\+:


\begin{DoxyItemize}
\item {\ttfamily V} -\/ Membrane potential
\item {\ttfamily U} -\/ Membrane recovery variable
\end{DoxyItemize}

Parameters are\+:
\begin{DoxyItemize}
\item {\ttfamily a} -\/ time scale of U
\item {\ttfamily b} -\/ sensitivity of U
\item {\ttfamily c} -\/ after-\/spike reset value of V
\item {\ttfamily d} -\/ after-\/spike reset value of U
\end{DoxyItemize}\hypertarget{sect2_sect25}{}\subsection{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H\+\_\+\+V (\+Izhikevich neurons with variable parameters)}\label{sect2_sect25}
This is the same model as \hyperlink{sect2_sect24}{I\+Z\+H\+I\+K\+E\+V\+I\+C\+H (Izhikevich neurons with fixed parameters)} I\+Z\+H\+I\+K\+E\+V\+I\+C\+H but parameters are defined as \char`\"{}variables\char`\"{} in order to allow users to provide individual values for each individual neuron instead of fixed values for all neurons across the population.

Accordingly, the model has the Variables\+:
\begin{DoxyItemize}
\item {\ttfamily V} -\/ Membrane potential
\item {\ttfamily U} -\/ Membrane recovery variable
\item {\ttfamily a} -\/ time scale of U
\item {\ttfamily b} -\/ sensitivity of U
\item {\ttfamily c} -\/ after-\/spike reset value of V
\item {\ttfamily d} -\/ after-\/spike reset value of U
\end{DoxyItemize}

and no parameters.\hypertarget{sect2_sect_own}{}\subsection{Defining your own neuron type}\label{sect2_sect_own}
In order to define a new neuron type for use in a Ge\+N\+N application, it is necessary to populate an object of class {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} and append it to the global vector {\ttfamily n\+Models}. The {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} class has several data members that make up the full description of the neuron model\+:


\begin{DoxyItemize}
\item {\ttfamily sim\+Code} of type {\ttfamily string\+:} This needs to be assigned a C++ string that contains the code for executing the integration of the model for one time step. Within this code string, variables need to be referred to by , where N\+A\+M\+E is the name of the variable as defined in the vector var\+Names. The code may refer to the predefined primitives {\ttfamily D\+T} for the time step size and {\ttfamily Isyn} for the total incoming synaptic current. ~\newline
 Example\+: 
\begin{DoxyCode}
\hyperlink{structneuronModel}{neuronModel} model;
model.\hyperlink{structneuronModel_a9e6536fd15b69fa24b708e41f97df899}{simCode}=String(\textcolor{stringliteral}{"$(V)+= (-$(a)$(V)+Isyn)*DT;"});
\end{DoxyCode}
 would implement a leaky itegrator $\frac{dV}{dt}= -a V + I_{{\rm syn}}$.
\item {\ttfamily var\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector needs to be filled with the names of variables that make up the neuron state. The variables defined here as {\ttfamily N\+A\+M\+E} can then be used in the syntax {\ttfamily } in the code string. ~\newline
 Example\+: 
\begin{DoxyCode}
model.\hyperlink{structneuronModel_a9a9156ffb643572fd67f6e585ef79ad0}{varNames}.push\_back(String(\textcolor{stringliteral}{"V"}));
\end{DoxyCode}
 would add the variable V as needed by the code string in the example above.
\item {\ttfamily var\+Types} of type {\ttfamily vector$<$string$>$}\+: This vector needs to be filled with the variable type (e.\+g. \char`\"{}float\char`\"{}, \char`\"{}double\char`\"{}, etc) for the variables defined in {\ttfamily var\+Names}. Types and variables are matched to each other by position in the respective vectors. ~\newline
 Example\+: 
\begin{DoxyCode}
model.\hyperlink{structneuronModel_a86788cb29131da0a26ce79693a076352}{varTypes}.push\_back(String(\textcolor{stringliteral}{"float"}));
\end{DoxyCode}
 would designate the variable V to be of type float. \begin{DoxyNote}{Note}
Variable names and variable types are matched by their position in the corresponding arrays {\ttfamily var\+Names} and {\ttfamily var\+Types}, i.\+e. the 0th entry of {\ttfamily var\+Names} will have the type stored in the 0th entry of {\ttfamily var\+Types} and so on.
\end{DoxyNote}

\item {\ttfamily p\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector will contain the names of parameters relevant to the model. If defined as {\ttfamily N\+A\+M\+E} here, they can then be referenced as {\ttfamily } in the code string. The length of this vector determines the expected number of parameters in the initialisation of the neuron model. Parameters are currently assumed to be always of type float. ~\newline
 
\begin{DoxyCode}
model.\hyperlink{structneuronModel_a4a5bf1f757a72b6edc28ad26ed61b2be}{pNames}.push\_back(String(\textcolor{stringliteral}{"a"}));
\end{DoxyCode}
 stores the parameter {\ttfamily a} needed in the code example above.
\item {\ttfamily dp\+Names} of type {\ttfamily vector$<$string$>$}\+: Names of \char`\"{}dependent
  parameters\char`\"{}. Dependent parameters are a mechanism for enhanced efficiency when running neuron models. If parameters with model-\/side meaning, such as time constants or conductances always appear in a certain combination in the model, then it is more efficient to pre-\/compute this combination and define it as a dependent parameter. This vector contains the names of such dependent parameters. ~\newline
 For example, if in the example above the original model had been $\frac{dV}{dt} = -g/C \, V +I_{\rm syn}$. Then one could define the code string and parameters as 
\begin{DoxyCode}
model.\hyperlink{structneuronModel_a9e6536fd15b69fa24b708e41f97df899}{simCode}=String(\textcolor{stringliteral}{"$(V)+= (-$(a)$(V)+Isyn)*DT;"});
model.\hyperlink{structneuronModel_a9a9156ffb643572fd67f6e585ef79ad0}{varNames}.push\_back(String(\textcolor{stringliteral}{"V"}));
model.\hyperlink{structneuronModel_a86788cb29131da0a26ce79693a076352}{varTypes}.push\_back(String(\textcolor{stringliteral}{"float"}));
model.\hyperlink{structneuronModel_a4a5bf1f757a72b6edc28ad26ed61b2be}{pNames}.push\_back(String(\textcolor{stringliteral}{"g"}));
model.\hyperlink{structneuronModel_a4a5bf1f757a72b6edc28ad26ed61b2be}{pNames}.push\_back(String(\textcolor{stringliteral}{"C"}));
model.\hyperlink{structneuronModel_a051c0c704ce383c43cdf446accbeb201}{dpNames}.push\_back(String(\textcolor{stringliteral}{"a"}));
\end{DoxyCode}
 In this case one would also need to provide a dependent parameter class, i.\+e. an implementation of \hyperlink{classdpclass}{dpclass} which would return the value for {\ttfamily a} when queried for dependent parameter 0 through {\ttfamily \hyperlink{classdpclass_a4227f736c0ec826d7bda6c98e783d74a}{dpclass\+::calculate\+Derived\+Parameter()}}. Examples how this is done can be found in the pre-\/defined classes, e.\+g. \hyperlink{classexpDecayDp}{exp\+Decay\+Dp}, \hyperlink{classpwSTDP}{pw\+S\+T\+D\+P}, \hyperlink{classrulkovdp}{rulkovdp} etc.
\item {\ttfamily tmp\+Var\+Names} of type {\ttfamily vector$<$string$>$}\+: This vector can be used to request additional variables that are not part of the state of the neuron but used only as temporary storage during evaluation of the integration time step.
\item {\ttfamily tmp\+Var\+Types} of type {\ttfamily vector$<$string$>$}\+: This vector will contain the variable types of the temporary variables.
\end{DoxyItemize}

Once the completed {\ttfamily \hyperlink{structneuronModel}{neuron\+Model}} object is appended to the {\ttfamily n\+Models} vector it can be used in network descriptions by referring to its cardinal number in the n\+Models vector. I.\+e., if the model is added as the 4th entry, it would be model \char`\"{}3\char`\"{} (counting starts at 0 in usual C convention). The information of the cardinal number of a new model can be obtained by referring to {\ttfamily n\+Models.\+size()} right before appending the new model.

For dependent parameters in a user-\/defined model, it is the user's responsibility to intitialize the derived parameters from the relevant entries of the global {\ttfamily neuron\+Para} vector entries, to store them in a vector and append this vector to the global vector {\ttfamily dnp}. This needs to be done right after the call to add\+Neuron\+Population that involves the neuron model in questions. For an example of what needs to be done, refer to the member function {\ttfamily init\+Derived\+Neuron\+Para()} of class {\ttfamily \hyperlink{classNNmodel}{N\+Nmodel}} which does this for Rulkov map neurons. \hypertarget{sect3}{}\section{Synapse models}\label{sect3}
\hypertarget{sect3_subsect31}{}\subsection{Models}\label{sect3_subsect31}
Currently 3 predefined synapse models are available\+:
\begin{DoxyItemize}
\item 0\+: \hyperlink{sect3_sect31}{N\+S\+Y\+N\+A\+P\+S\+E}
\item 1\+: \hyperlink{sect3_sect32}{N\+G\+R\+A\+D\+S\+Y\+N\+A\+P\+S\+E}
\item 2\+: \hyperlink{sect3_sect33}{L\+E\+A\+R\+N1\+S\+Y\+N\+A\+P\+S\+E}
\end{DoxyItemize}